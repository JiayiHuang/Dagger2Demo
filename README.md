Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。

使用中的主要注解有：
@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。

#### 1 @Inject：
有两个作用：

1. 用来标记需要依赖的变量，以此告诉 Dagger2 为它提供依赖；
2. 用来标记构造函数，Dagger2 通过 @Inject 注解可以在需要这个实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被 @Inject 标记的变量提工依赖。

#### 2 @Module
用于标注提供依赖的类。上面 @Inject 的第二个用图就是用来提供依赖，用途不是重复了吗？因为：

1. 很多时候提供依赖的类是第三方库的，我们没法给他加上 @Inject 注解；
2. 很多时候，创建依赖的实例需要参数，单独使用 @Inject 无法解决。

    @Inject 和 @Module 的使用选择：
    1. 首先查找 @Module 标注的类中是否存在提供依赖的方法
    2. 若存在提供依赖的方法，查看该方法是否存在参数
        a. 存在，则按 步骤1 一次初始化每个参数。
        b. 不存在，则直接初始化该类的实例，完成一次依赖注入。
    3. 若不存在提供依赖的方法，则查找 @Inject 标注的构造函数，看构造函数是否存在参数。
	    a. 存在，则从 步骤1 开始一次初始化每一个参数。
	    b. 不存在，直接初始化该实例，完成一次注入。


#### 3 @Provides：
用于标注 @Module 注解所标注类中的方法，该方法在需要提供依赖时被调用，从而把预设好的对象当做依赖给标注了 @Inject 的变量赋值。

#### 4 @Component：
只能用于标注接口或抽象类，是依赖需求方和提供方的桥梁。被此注解标注的接口在编译时会生成该接口的实现类（DaggerXxxComponent），我们通过调用这个类的实现类的方法完成注入。

#### 5 @Qualifier：
用于自定义注解，如同 Java 提供的几种基本元注解一样用来标记注解类。
我们在使用 @Module 来标记 依赖提供方的类时，具体提供依赖的方法名可能是随便定义的（命名规范，provideXxx）。Dagger2 是根据返回值类型来确定方法具体为那个属性提供依赖。但是如果有多个相同返回值的 依赖提供方法时，Dagger2 就会报错。此时，就需要 @Qualifier 注解，它就是为了解决这个问题，我们使用 @Qualifier 来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被 @Inject 标记的属性变量），这样 Dagger2 就知道为谁提供依赖了。
一个精简的定义：但类型不足以鉴别一个依赖时，我们就可以使用这个注解标示。

#### 6 @Scope：
同样用于自定义注解，通过自定义来限定注解的作用域，实现局部单例

#### 7 @Singleton
其实就是一个通过 @Scope 定义的注解，一般通过它来实现全局单例。但实际上并不能提供全局单例，是否能提供全局单例还要取决于对应的 Component 是否为一个全局对象。